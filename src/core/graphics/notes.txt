Collision system:
- Every element needs to have a hitbox, defined using its x,y coordinates.
- The collision system has two elements:
  + The collision detection system: it detects the collision of two elems based on their hitboxes.
  + The collision evaluation system: it evaluates what needs to happen (both logically and graphically) depending on the types and properties of the elems that collide.
- There are 2 options for the design of the collision detection system:
  1. When each elem moves (using its own thread) it loops through the elems vector and checks if it collides with some other elem. If it does, it triggers the collision evaluation system. This is more efficient but ugly code (a lot of repetition), needing to do at most N_ELEMS^2 checks (assuming movements are synchronized with frames; the edge case happens when all elements move in a frame). Such starategy can be "cleaned" if each thread controlling the movement of an object takes care of the calculations to design the movement but delegates the movement itself (lock the mutex, change the values of x and y and unlock the mutex) to a generic moveElem(Elem, x, y) function, which would first check for collisions and handle them.
  2. Before drawing a frame, the collision detection system is called: it loops through every pair of elems to check for collisions and triggers the collision evaluation system for any collision found. This is more inneficient, as it always needs to do N_ELEMS^2 checks (since it does not know if an elem did or did not move since the last frame). However, it is cleaner as the system is only invoked once every frame, from one place.

Frame synchronisation:
- The main function needs to wait x ms (depending on target fps) to render and debuffer every frame. 
- Every element's moves must be synchronized so that each element only moves once (one iteration of the moving loop) per frame.
